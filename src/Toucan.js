/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei';
import * as THREE from 'three';




export default function Model({ ...props }) {
  const group = useRef()
  const { nodes, materials } = useGLTF('/toucan.gltf')
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 10, 50);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0xe0b2a4, 1.0);
  document.body.appendChild(renderer.domElement);

  var bulb_mesh = new THREE.Mesh(nodes, materials);

  bulb_mesh.name = 'bulb';
  bulb_mesh.position.set(0, 0, 0);
  scene.add(bulb_mesh);

  class MouseMeshInteractionHandler {
    constructor(mesh_name, handler_function) {
      this.mesh_name = mesh_name;
      this.handler_function = handler_function;
    }
  }

  class MouseMeshInteraction {
    constructor(scene, camera) {
      this.scene = scene;
      this.camera = camera;

      this.raycaster = new THREE.Raycaster();
      this.mouse = new THREE.Vector2();

      this.updated = false;
      this.event = '';

      // last mesh that the mouse cursor was over
      this.last_mouseenter_mesh = undefined;
      // last mesh that the mouse was pressing down
      this.last_pressed_mesh = undefined;

      this.handlers = new Map();

      this.handlers.set('click', []);
      this.handlers.set('dblclick', []);
      this.handlers.set('contextmenu', []);

      this.handlers.set('mousedown', []);
      this.handlers.set('mouseup', []);
      this.handlers.set('mouseenter', []);
      this.handlers.set('mouseleave', []);

      window.addEventListener('mousemove', this);

      window.addEventListener('click', this);
      window.addEventListener('dblclick', this);
      window.addEventListener('contextmenu', this);

      window.addEventListener('mousedown', this);
    }

    handleEvent(e) {
      switch (e.type) {
        case "mousemove": {
          this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
          this.updated = true;
          this.event = 'motion';
        }
          break;
        default: {
          this.updated = true;
          this.event = e.type;
        }
      }
    }

    addHandler(mesh_name, event_type, handler_function) {
      if (this.handlers.has(event_type)) {
        this.handlers.get(event_type).push(new MouseMeshInteractionHandler(mesh_name, handler_function));
      }
    }

    update() {
      if (this.updated) {
        // update the picking ray with the camera and mouse position
        this.raycaster.setFromCamera(this.mouse, this.camera);

        // calculate objects intersecting the picking ray
        const intersects = this.raycaster.intersectObjects(this.scene.children, true);

        if (intersects.length > 0) {
          // special test for events: 'mouseenter', 'mouseleave'
          if (this.event === 'motion') {
            let mouseenter_handlers = this.handlers.get('mouseenter');
            let mouseleave_handlers = this.handlers.get('mouseleave');

            if (mouseleave_handlers.length > 0) {
              for (const handler of mouseleave_handlers) {
                // if mesh was entered by mouse previously, but not anymore, that means it has been mouseleave'd
                if (
                  this.last_mouseenter_mesh !== undefined
                  && intersects[0].object !== this.last_mouseenter_mesh
                  && handler.mesh_name === this.last_mouseenter_mesh.name
                ) {
                  handler.handler_function(this.last_mouseenter_mesh);
                  break;
                }
              }
            }

            if (mouseenter_handlers.length > 0) {
              for (const handler of mouseenter_handlers) {
                if (handler.mesh_name === intersects[0].object.name && intersects[0].object !== this.last_mouseenter_mesh) {
                  this.last_mouseenter_mesh = intersects[0].object;
                  handler.handler_function(intersects[0].object);
                  break;
                }
              }
            }
          }
          else {
            // if mouseup event has occurred
            if (this.event === 'click' && this.last_pressed_mesh === intersects[0].object) {
              for (const handler of this.handlers.get('mouseup')) {
                if (handler.mesh_name === intersects[0].object.name) {
                  handler.handler_function(intersects[0].object);
                  break;
                }
              }
              this.last_pressed_mesh = undefined;
            }

            // for mouseup event handler to work
            if (this.event === 'mousedown') {
              this.last_pressed_mesh = intersects[0].object;
            }

            let handlers_of_event = this.handlers.get(this.event);
            for (const handler of handlers_of_event) {
              if (handler.mesh_name === intersects[0].object.name) {
                handler.handler_function(intersects[0].object);
                break;
              }
            }
          }
        }
        // if mouse doesn't intersect any meshes
        else if (this.event === 'motion') {
          // special test for 'mouseleave' event
          // 			(since it may be triggered when cursor doesn't intersect with any meshes)
          for (const handler of this.handlers.get('mouseleave')) {
            // if mesh was entered by mouse previously, but not anymore, that means it has been mouseleave'd
            if (this.last_mouseenter_mesh !== undefined && handler.mesh_name === this.last_mouseenter_mesh.name) {
              handler.handler_function(this.last_mouseenter_mesh);
              this.last_mouseenter_mesh = undefined;
              break;
            }
          }
        }

        this.updated = false;
      }
    }
  }


  const mmi = new MouseMeshInteraction(scene, camera);
  mmi.addHandler('bulb', 'click', function (mesh) {
    console.log("bulb has been clicked!");
  });


  return (
    <group ref={group} {...props} dispose={null}>
      <mesh geometry={nodes.Plane047.geometry} material={materials['Material.020']} position={[-10, 35, -25]} />
    </group>
  )

}



useGLTF.preload('/toucan.gltf')
